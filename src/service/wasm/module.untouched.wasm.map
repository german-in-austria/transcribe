{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","~lib/memory.ts","~lib/internal/memory.ts","src/service/wasm/waveform.ts","~lib/internal/typedarray.ts","~lib/internal/arraybuffer.ts","~lib/array.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n// Memory allocator interface\n\n@global export function __memory_allocate(size: usize): usize {\n  if (size > MAX_SIZE_32) unreachable();\n  var ptr = offset;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n  }\n  offset = newPtr;\n  return ptr;\n}\n\n@global export function __memory_free(ptr: usize): void { /* nop */ }\n\n@global export function __memory_reset(): void {\n  offset = startOffset;\n}\n","import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @inline export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; }\n    memset(dest, c, n);\n  }\n\n  @inline export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; }\n    memmove(dest, src, n);\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n);\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n","// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest == src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","// import 'assemblyscript/std/assembly/index'\n// const loader = require(\"@assemblyscript/loader\");\n// import {} from 'assemblyscript/std/types/assembly'\nimport 'allocator/arena'\n\nexport { memory }\n\n// declare function log(s: i32): void\n\n@inline function getInput(index: i32): f32 {\n  return load<f32>(index << 2, 0);\n}\n\nexport function drawWavePath(arr: Float32Array, output: f32[], width: i32, height: i32, offsetLeft: i32): f32[] {\n  // const lowerHalf: f32[] = []\n  // const upperHalf: f32[] = []\n  const step = ceil<i32>( arr.length / width )\n  const amp = height / 2\n  for (let i: i32 = 0; i < width; i++) {\n    let minimum: f32 = 1.0\n    let maximum: f32 = -1.0\n    for (let j: i32 = 0; j < step; j++) {\n      let datum = arr[i * step + j]\n      if (datum < minimum) {\n        minimum = datum\n      }\n      if (datum > maximum) {\n        maximum = datum\n      }\n    }\n    output.push((1 + minimum) * <f32>amp)\n    output.push(max<f32>(1, (maximum - minimum) * <f32>amp) + ((1 + minimum) * <f32>amp))\n    // upperHalf.push( (1 + minimum) * <f32>amp )\n    // lowerHalf.unshift(max<f32>(1, (maximum - minimum) * <f32>amp) + ((1 + minimum) * <f32>amp))\n  }\n  // _log(upperHalf + lowerHalf)\n  return output\n}\n","import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  loadUnsafeWithOffset,\n  storeUnsafeWithOffset\n} from \"./arraybuffer\";\n\nimport {\n  insertionSort,\n  weakHeapSort,\n  defaultComparator\n} from \"./array\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T,V> {\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return (this.byteLength - this.byteOffset) >> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    var byteOffset = this.byteOffset;\n    var elementLength = (this.byteLength - byteOffset) >>> alignof<T>();\n    if (<u32>index >= <u32>elementLength) throw new Error(\"Index out of bounds\");\n    return loadUnsafeWithOffset<T,T>(this.buffer, index, byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return loadUnsafeWithOffset<T,T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: V): void {\n    var byteOffset = this.byteOffset;\n    var elementLength = (this.byteLength - byteOffset) >>> alignof<T>();\n    if (<u32>index >= <u32>elementLength) throw new Error(\"Index out of bounds\");\n    storeUnsafeWithOffset<T,V>(this.buffer, index, value, byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: V): void {\n    storeUnsafeWithOffset<T,V>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n\n  @inline\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): TypedArray<T,V> {\n    var length = this.length;\n    if (begin < 0) begin = max(length + begin, 0);\n    else begin = min(begin, length);\n    if (end < 0) end = max(length + end, begin);\n    else end = max(min(end, length), begin);\n    var slice = memory.allocate(offsetof<this>());\n    store<usize>(slice, this.buffer, offsetof<this>(\"buffer\"));\n    store<i32>(slice, begin << alignof<T>(), offsetof<this>(\"byteOffset\"));\n    store<i32>(slice, end << alignof<T>(), offsetof<this>(\"byteLength\"));\n    return changetype<this>(slice);\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = defaultComparator<T>()): this {\n    var byteOffset = this.byteOffset;\n    var length = this.length;\n    if (length <= 1) return this;\n    var buffer = this.buffer;\n    if (length == 2) {\n      let a = loadUnsafeWithOffset<T,T>(buffer, 1, byteOffset);\n      let b = loadUnsafeWithOffset<T,T>(buffer, 0, byteOffset);\n      if (comparator(a, b) < 0) {\n        storeUnsafeWithOffset<T,T>(buffer, 1, b, byteOffset);\n        storeUnsafeWithOffset<T,T>(buffer, 0, a, byteOffset);\n      }\n      return this;\n    }\n\n    if (isReference<T>()) {\n      // TODO replace this to faster stable sort (TimSort) when it implemented\n      insertionSort<T>(buffer, byteOffset, length, comparator);\n      return this;\n    } else {\n      if (length < 256) {\n        insertionSort<T>(buffer, byteOffset, length, comparator);\n      } else {\n        weakHeapSort<T>(buffer, byteOffset, length, comparator);\n      }\n      return this;\n    }\n  }\n}\n","import { AL_MASK, MAX_SIZE_32 } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n      memory.fill(\n        changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      memory.fill(\n        changetype<usize>(newBuffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n      return newBuffer;\n    }\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n@inline export function loadUnsafe<T,V>(buffer: ArrayBuffer, index: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline export function storeUnsafe<T,V>(buffer: ArrayBuffer, index: i32, value: V): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n\n@inline export function loadUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, byteOffset: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline export function storeUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, value: V, byteOffset: i32): void {\n  store<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n","import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  loadUnsafe,\n  storeUnsafe\n} from \"./internal/arraybuffer\";\n\nimport {\n  defaultComparator,\n  insertionSort,\n  weakHeapSort\n} from \"./internal/array\";\n\nexport class Array<T> {\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (!callbackfn(loadUnsafe<T,T>(buffer, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (predicate(loadUnsafe<T,T>(buffer, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? loadUnsafe<T,T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator(\"{}\")\n  private __unchecked_get(index: i32): T {\n    return loadUnsafe<T,T>(this.buffer_, index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    storeUnsafe<T,T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator(\"{}=\")\n  private __unchecked_set(index: i32, value: T): void {\n    storeUnsafe<T,T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len    = this.length_;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (sizeof<T>() == 1) {\n      memory.fill(\n        changetype<usize>(buffer) + start + HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    } else {\n      for (; start < end; ++start) {\n        storeUnsafe<T,T>(buffer, start, value);\n      }\n    }\n    return this;\n  }\n\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return false;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return true;\n      ++fromIndex;\n    }\n    return false;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (loadUnsafe<T,T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    storeUnsafe<T,T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var element = loadUnsafe<T,T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      callbackfn(loadUnsafe<T,T>(buffer, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var resultBuffer = result.buffer_;\n    for (let index = 0; index < length && index < this.length_; ++index) {\n      storeUnsafe<U,U>(resultBuffer, index, callbackfn(loadUnsafe<T,T>(buffer, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var buffer = this.buffer_;\n    var length = this.length_;\n    var result = new Array<T>();\n    for (let index = 0; index < length && index < this.length_; ++index) {\n      let value = loadUnsafe<T,T>(buffer, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      accum = callbackfn(accum, loadUnsafe<T,T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    var buffer = this.buffer_;\n    for (let index: i32 = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, loadUnsafe<T,T>(buffer, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var buffer = this.buffer_;\n    var element = loadUnsafe<T,T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    storeUnsafe<T,T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    var buffer = this.buffer_;\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\n      if (callbackfn(loadUnsafe<T,T>(buffer, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    storeUnsafe<T,T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    if (begin < 0) begin = max(length + begin, 0);\n    else if (begin > length) begin = length;\n    if (end < 0) end = length + end; // no need to clamp\n    else if (end > length) end = length;\n    if (end < begin) end = begin;    // ^\n    var newLength = end - begin;\n    assert(newLength >= 0);\n    var sliced = new Array<T>(newLength);\n    if (newLength) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>newLength << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1) return;\n    var length = this.length_;\n    if (start < 0) start = max(length + start, 0);\n    if (start >= length) return;\n    deleteCount = min(deleteCount, length - start);\n    var buffer = this.buffer_;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>()),\n      changetype<usize>(buffer) + HEADER_SIZE + (<usize>(start + deleteCount) << alignof<T>()),\n      <usize>deleteCount << alignof<T>()\n    );\n    this.length_ = length - deleteCount;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = loadUnsafe<T,T>(buffer, front);\n      storeUnsafe<T,T>(buffer, front, loadUnsafe<T,T>(buffer, back));\n      storeUnsafe<T,T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = defaultComparator<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = loadUnsafe<T,T>(buffer, 1); // a = arr[1]\n      let b = loadUnsafe<T,T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        storeUnsafe<T,T>(buffer, 1, b);   // arr[1] = b;\n        storeUnsafe<T,T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n\n    if (isReference<T>()) {\n      // TODO replace this to faster stable sort (TimSort) when it implemented\n      insertionSort<T>(buffer, 0, length, comparator);\n      return this;\n    } else {\n      if (length < 256) {\n        insertionSort<T>(buffer, 0, length, comparator);\n      } else {\n        weakHeapSort<T>(buffer, 0, length, comparator);\n      }\n      return this;\n    }\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n"]}